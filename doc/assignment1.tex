\documentclass{article}
\usepackage{a4wide}
\setlength{\parindent}{0pt}
\title{Web Data Management, assignment 1}
\author{Hans van den Bogert\\(studienummer) \and Bastiaan van Graafeiland\\1399101}
\begin{document}
\maketitle

\section{XPath assignments}
We will have to device queries for both the movies dataset as well as the movies\_refs dataset. The latter has actors and movies seperated.

\subsection{All title elements}
For both the data sets, titles can be retrieved by:
\begin{verbatim}
//title
\end{verbatim}

\subsection{All movie title (i.e. the textual value of title element)}
Every node has a text representation.
\begin{verbatim}
//title/text()
\end{verbatim}

\subsection{Titles of the movies published after 2000}
Assuming 'after 2000' means 2001 and up, the following added predicate will work on both xml files:
\begin{verbatim}
/movies/movie[year>2000]/title
\end{verbatim}

\subsection{Summary of "Spiderman"}
The movie named "Spiderman" does not exist. Assuming "Spider-Man" was meant, the following query will provide the movie's summary:
\begin{verbatim}
/movies/movie[title='Spider-Man']/summary
\end{verbatim}

\subsection{Who is the director of Heat}
\subsubsection{movies.xml}
\begin{verbatim}
/movies/movie[title='Heat']/director
\end{verbatim}
\subsubsection{movies\_refs.xml}
We need to reference the id we get in the case of the \emph{movies\_refs.xml} file.
\begin{verbatim}
//artist[@id=//movie[title='Heat']/director/@id]
\end{verbatim}
% /movies/artist[@id=string(doc('/db/movies/movies\_refs.xml')/movies/movie[title/text()='Heat']/director/@id)]

\subsection{Title of the movies featuring Kirsten Dunst}
\subsubsection{movies.xml}
\begin{verbatim}
//movie[actor/first\_name='Kirsten'][actor/last_name='Dunst']/title
\end{verbatim}
\subsubsection{movies\_refs.xml}
\begin{verbatim}
//movie[actor/@id = //artist[last_name='Dunst' and first_name='Kirsten']/@id]
	/title
\end{verbatim}

\subsection{Which movies have a summary}
\begin{verbatim}
//movie[summary]
\end{verbatim}

\subsection{Which movies do not have a summary}
\begin{verbatim}
//movie[not(summary)]
\end{verbatim}
\texttt{count()} could have been used as well, counting the number of \emph{summary} elements.

\subsection{Titles of the movies published more than 5 years ago}
The following query gets the current date, extracts the year, substracts 5 years and then uses that year as a predicate.
\begin{verbatim}
//movie[year < (year-from-dateTime(current-dateTime()) - 5)]/title
\end{verbatim}

\subsection{What was the role of Clint Eastwood in Unforgiven?}
\subsubsection{movies.xml}
\begin{verbatim}
//movie[title='Unforgiven']/actor[first_name = 'Clint' and last_name = 'Eastwood']/role
\end{verbatim}
\subsubsection{movies\_refs.xml}
\begin{verbatim}
//movie[title='Unforgiven']
	/actor[@id = //artist[first_name='Clint' and last_name='Eastwood']/@id]
	/@role/string()
\end{verbatim}
The result differs with the \emph{movies.xml} query, where the result was a node rather than a string. This is inherent to the structure changes where role is either an attribute or a node itself. The assignment was not specific in the desired result.

\subsection{What is the last movie of the document}
\begin{verbatim}
//movie[last()]
\end{verbatim}

\subsection{Title of the film that immediately precedes Marie Antoinette in the document}
In both sets:
\begin{verbatim}
//movie[title='Marie Antoinette']/preceding-sibling::movie[1]/title
\end{verbatim}
The first element in the set of preceding siblings has to be obtained, because the axis is backwards.

\subsection{Get the movies whose title contains "V"}
Restricted to uppercase "V", the query for both data-sets:
\begin{verbatim}
//movie[contains(title, 'V')]
\end{verbatim}

\subsection{Get the movies whose cast consists of exactly three actors}
\begin{verbatim}
//movie[count(actor) = 3]
\end{verbatim}

\section{XQuery assignments}
For all queries these lines are implicit:
\begin{verbatim}
let $ms:=doc("movies-query/movies\_alone.xml"),
$as:=doc("movies-query/artists\_alone.xml")
\end{verbatim}
\subsection{List the movies published after 2002, including their
  title and year}
As the assignment was not clear on desired output, we've done our best,

\begin{verbatim}
for $m in $ms/movies/movie 
where year > 2002 
return (concat($m/title/text(),"",$m/year/text()))
\end{verbatim}

\subsection{Create a flat list of all the title-role pairs, with each
  pair enclosed in a “result” element. Here is an example of the
  expected result structure:...}
\begin{verbatim}
<results>{    
let $ms:=doc("movies-query/movies\_alone.xml"),                                                                                           
$as:=doc("movies-query/artists\_alone.xml")

    for $role in $ms/movies/movie/actor/@role

    return <result>
            <title>{
                $role/../../title/string()
            }</title>
            <role>{
                $role/string()
            }
            </role>
        </result>
}
</results>
\end{verbatim}
\subsection{ Give the title of movies where the director is also one
  of the actors.}
\begin{verbatim}
for $a in $ms//movie
where $a/director/@id = $a/actor/@id
return $a/title
\end{verbatim}
\subsection{ Show the movies, grouped by genre. Hint: function
  distinct-values() removes the duplicates from a sequence. It returns
  atomic values.}
The requested format is unclear, we opted for a list of tuples with
the return type ($genre, $corresponding-movie-title )
\begin{verbatim}
let $ms:=doc("movies-query/movies\_alone.xml"),                                                                                           
$as:=doc("movies-query/artists\_alone.xml")

for $g in distinct-values($ms//genre)
return ($g,$ms//movie[genre= $g]/title)
\end{verbatim}

\subsection{ For each distinct actor's id in movies\_alone.xml, show
  the titles of the movies where this actor plays a role. The format
  of the result should be:...}
\begin{verbatim}
for $id in distinct-values($ms//actor/@id/string())
return  <actor>{$id},{
    for $m in $ms//movie[actor/@id/string() = $id]
    return $m/title
}
</actor>
\end{verbatim}

\subsubsection{variant:}
The variant asks only for the nodes/actors which at least appear in 2
movies, we can do so by capturing all the nodes, but before outputting
we filter -- using the provided hint -- with the \emph{count()}
function.

\begin{verbatim}
let $acs := for $id in distinct-values($ms//actor/@id/string())
return  <actor>{$id},{
    for $m in $ms//movie[actor/@id/string() = $id]
    return $m/title
}
</actor>

return $acs[count(title) = 2]
\end{verbatim}
\subsection{ Give the title of each movie, along with the name of its
  director. Note: this is a join!}
The result is a tuple of the movie title and the director's name.
\begin{verbatim}
for $m in $ms//movie
,   $a in $as//artist
where $m/director/@id = $a/@id  
return ($m/title/text(), concat($a/first_name, " ",$a/last_name))
\end{verbatim}
\subsection{ Give the title of each movie, and a nested element
  <actors> giving the list of actors with their role.  }

Again the desired output is very ambiguous and left open for
interpretation, we read it as: (1) sequence the titles as elements, in
these titles include (nest) an extra element actors which has actor
elements existing of the actors with their real name, while having a
role attribute.

\begin{verbatim}
for $m in $ms//movie return 
<title>{                                                                                                                  
    $m//title/text()} <actors>
    {for $ac in $m/actor
    , $ar in $as//artist 
    where $ac/@id = $ar/@id 
    return 
        <actor role="{$ac/@role/string()}''>                                                                                                                          
            {$ar/first_name/text()}\&#032;{$ar/last_name/text()}         
        </actor>} 
    </actors>
</title>

\end{verbatim}
\subsection{ For each movie that has at least two actors, list the
  title and first two actors, and an empty "et-al" element if the
  movie has additional actors. For instance: }
\begin{verbatim}
<results>{
    let $ms:=doc("movies-query/movies\_alone.xml")
    , $as:=doc("movies-query/artists\_alone.xml")
    
    for $m in $ms//movie
    return
    <result>
        <title>
            {$m//title/text()}             
        </title>
        {for $ac in subsequence($m/actor, 1,2)
        , $ar in $as//artist 
        where $ac/@id = $ar/@id 
        return 
        <actor>                                                                                                                          
            {$ar/first_name/text()}\&#032;{$ar/last_name/text()} as  {$ac/@role/string()}
        </actor>}
        {if(count($m/actor) > 2 ) then <et-al/> else ""}
    </result>
}</results>
\end{verbatim}

\subsection{ List the titles and years of all movies directed by Clint
  Eastwood after 1990, in alphabetic order.  }

We've chosen to result the titles and years as list of tuples ($title, $year)
\begin{verbatim}
let $eastwoodId := $as//artist[last_name = "Eastwood"]/@id

for $m in $ms//movie
where $m//director/@id/string() = $eastwoodId/string()
and $m/year > 1990
order by $m/title
return ($m//title, $m/year)
\end{verbatim}

\section{Project: Getting started}

\end{document}