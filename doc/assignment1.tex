\documentclass{article}
\usepackage{a4wide}
\setlength{\parindent}{0pt}
\title{Web Data Management, assignment 1}
\author{Hans van den Bogert\\(studienummer) \and Bastiaan van Graafeiland\\1399101}
\begin{document}
\maketitle

\section{XPath assignments}
We will have to device queries for both the movies dataset as well as the movies\_refs dataset. The latter has actors and movies seperated.

\subsection{All title elements}
For both the data sets, titles can be retrieved by:
\begin{verbatim}
//title
\end{verbatim}

\subsection{All movie title (i.e. the textual value of title element)}
Every node has a text representation.
\begin{verbatim}
//title/text()
\end{verbatim}

\subsection{Titles of the movies published after 2000}
Assuming 'after 2000' means 2001 and up, the following added predicate will work on both xml files:
\begin{verbatim}
/movies/movie[year>2000]/title
\end{verbatim}

\subsection{Summary of "Spiderman"}
The movie named "Spiderman" does not exist. Assuming "Spider-Man" was meant, the following query will provide the movie's summary:
\begin{verbatim}
/movies/movie[title='Spider-Man']/summary
\end{verbatim}

\subsection{Who is the director of Heat}
\subsubsection{movies.xml}
\begin{verbatim}
/movies/movie[title='Heat']/director
\end{verbatim}
\subsubsection{movies\_refs.xml}
We need to reference the id we get in the case of the \emph{movies\_refs.xml} file.
\begin{verbatim}
//artist[@id=//movie[title='Heat']/director/@id]
\end{verbatim}
% /movies/artist[@id=string(doc('/db/movies/movies\_refs.xml')/movies/movie[title/text()='Heat']/director/@id)]

\subsection{Title of the movies featuring Kirsten Dunst}
\subsubsection{movies.xml}
\begin{verbatim}
//movie[actor/first\_name='Kirsten'][actor/last_name='Dunst']/title
\end{verbatim}
\subsubsection{movies\_refs.xml}
\begin{verbatim}
//movie[actor/@id = //artist[last_name='Dunst' and first_name='Kirsten']/@id]
	/title
\end{verbatim}

\subsection{Which movies have a summary}
\begin{verbatim}
//movie[summary]
\end{verbatim}

\subsection{Which movies do not have a summary}
\begin{verbatim}
//movie[not(summary)]
\end{verbatim}
\texttt{count()} could have been used as well, counting the number of \emph{summary} elements.

\subsection{Titles of the movies published more than 5 years ago}
The following query gets the current date, extracts the year, substracts 5 years and then uses that year as a predicate.
\begin{verbatim}
//movie[year < (year-from-dateTime(current-dateTime()) - 5)]/title
\end{verbatim}

\subsection{What was the role of Clint Eastwood in Unforgiven?}
\subsubsection{movies.xml}
\begin{verbatim}
//movie[title='Unforgiven']
	/actor[first_name='Clint' and last_name='Eastwood']/role
\end{verbatim}
\subsubsection{movies\_refs.xml}
\begin{verbatim}
//movie[title='Unforgiven']
	/actor[@id = //artist[first_name='Clint' and last_name='Eastwood']/@id]
	/@role/string()
\end{verbatim}
The result differs with the \emph{movies.xml} query, where the result was a node rather than a string. This is inherent to the structure changes where role is either an attribute or a node itself. The assignment was not specific in the desired result.

\subsection{What is the last movie of the document}
\begin{verbatim}
//movie[last()]
\end{verbatim}

\subsection{Title of the film that immediately precedes Marie Antoinette in the document}
In both sets:
\begin{verbatim}
//movie[title='Marie Antoinette']/preceding-sibling::movie[1]/title
\end{verbatim}
The first element in the set of preceding siblings has to be obtained, because the axis is backwards.

\subsection{Get the movies whose title contains "V"}
Restricted to uppercase "V", the query for both data-sets:
\begin{verbatim}
//movie[contains(title, 'V')]
\end{verbatim}

\subsection{Get the movies whose cast consists of exactly three actors}
\begin{verbatim}
//movie[count(actor) = 3]
\end{verbatim}

\section{XQuery assignments}
For all queries these lines are implicit:
\begin{verbatim}
let $ms:=doc("movies-query/movies_alone.xml"),
		$as:=doc("movies-query/artists_alone.xml")
\end{verbatim}

\subsection{List the movies published after 2002, including their title and year}
The assignment was not entirely clear on the expected output, so it's just a string.
\begin{verbatim}
for $m in $ms/movies/movie
where year > 2002
return concat($m/title/text(), ', ', $m/year/text())
\end{verbatim}

\subsection{Create a flat list of all the title-role pairs, with each pair enclosed in a \emph{result}ù element. Here is an example of the expected result structure:...}
\begin{verbatim}
<results>
{
    for $role in $ms/movies/movie/actor/@role
    return <result>
    	{$role/../../title}
    	<role>{$role/string()}</role>
    	</result>
}
</results>
\end{verbatim}

\subsection{ Give the title of movies where the director is also one of the actors.}
\begin{verbatim}
for $m in $ms//movie
where director/@id = actor/@id
return $m/title
\end{verbatim}

\subsection{ Show the movies, grouped by genre. Hint: function distinct-values() removes the duplicates from a sequence. It returns atomic values.}
The requested format is unclear, we opted for a list of tuples with the return type (genre, corresponding movie title)
\begin{verbatim}
for $g in distinct-values($ms//genre)
return ($g,$ms//movie[genre=$g]/title)
\end{verbatim}
Alternatively, \texttt{group by} could be used:
\begin{verbatim}
for $m in $ms//movie
let $g := $m/genre
group by $g
return ($g, $m/title)
\end{verbatim}

\subsection{For each distinct actor's id in movies\_alone.xml, show the titles of the movies where this actor plays a role. The format of the result should be:...}
\begin{verbatim}
for $id in distinct-values($ms//actor/@id)
let $movies := $ms//movie[actor/@id=$id]
return <actor>{$id, $movies/title} </actor>
\end{verbatim}

\subsubsection{Variant}
The variant asks only for the nodes/actors which appear in at least 2 movies. This can be achieved by adding a \texttt{where} clause to the query:
\begin{verbatim}
for $id in distinct-values($ms//actor/@id)
let $movies := $ms//movie[actor/@id=$id]
where count($movies) > 1
return <actor>{$id, $movies/title} </actor>
\end{verbatim}

\subsection{Give the title of each movie, along with the name of its director. Note: this is a join!}
The result is a concatenation of the movie title and the director's name.
\begin{verbatim}
for $m in $ms//movie, $a in $as//artist
where $m/director/@id = $a/@id
return concat($m/title, ": ", $a/last_name, ', ', $a/first_name)
\end{verbatim}

\subsection{Give the title of each movie, and a nested element <actors> giving the list of actors with their role.}
Again the desired output is very ambiguous and left open for interpretation, we read it as: (1) sequence the titles as elements, in these titles include (nest) an extra element actors which contains elements for the actor's name and role.
\begin{verbatim}
for $m in $ms//movie
let $actors := $as//artist[@id = $m/actor/@id]
return <title>{$m/title/text()}<actors>{
    for $a in $actors
    let $role := $m/actor[@id=$a/@id]/@role/string()
    return <actor>
        <name>{concat($a/first_name, " ", $a/last_name)}</name>
        <role>{$role}</role>
        </actor>
}</actors></title>
\end{verbatim}
Another interpretation would be to have the role as an attribute:
\begin{verbatim}
for $m in $ms//movie return 
<title>{$m//title/text()}
    <actors>
    {for $ac in $m/actor, $ar in $as//artist
    where $ac/@id = $ar/@id
    return 
        <actor role="{$ac/@role/string()}">                                   
            {$ar/first_name/text()}\&#032;{$ar/last_name/text()}
        </actor>}
    </actors>
</title>
\end{verbatim}

\subsection{ For each movie that has at least two actors, list the title and first two actors, and an empty "et-al" element if the movie has additional actors. For instance: (...)}
\begin{verbatim}
for $m in $ms//movie
let $actors := $as//artist[@id = $m/actor/@id]
where count($actors) >= 2
return 
		<result>{
			$m/title,
	    for $a in subsequence($actors, 1, 2)
	    let $role := $m/actor[@id=$a/@id]/@role/string()
	    return
	    	<actor>
	    		{concat($a/first_name, ' ', $a/last_name), ' as ', $role}
	    	</actor>,
	    if (count($actors) > 2) then <et-al/> else ''}
    </result>
\end{verbatim}

\subsection{List the titles and years of all movies directed by Clint Eastwood after 1990, in alphabetic order.}
The output is a \emph{result} element, containing the title and year as nested elements.
\begin{verbatim}
let $eastwoodId := $as//artist[last_name="Eastwood"]/@id/string()
for $m in $ms//movie
where $m/director/@id/string() = $eastwoodId and $m/year > 1990
order by $m/title ascending
return <result>{$m/title, $m/year}</result>
\end{verbatim}

\section{Project: Getting started}
\section{Shakespeare application}
The assignment was not clear on which collection should be used, there
were 2 choices: (1) The 3 works of Shakespeare in the samples
directory actually \emph{shipped} with the eXist-db, or (2) the
application downloadable by the package manager in eXist-db, we chose
the former.  Some parts we're reused from the samples directory,
namely the xsl file.

The application is built using the application-framework of eXist-db
much like the Shakespeare application demo, although we've chosen to
use xslt to do most of the transformations instead of using xquery.

The following lists depicts the step taken from a request to the
exist-db by the exist-db to render the page.
\begin{enumerate}
\item The controller.xql receives the URL request and routes it
  accordingly - usually to view.xql
\item the view.xql looks at the original request and finds the
  appropriate html file, like index.html, view-play.html etc.
\item The view.xql then parses this HTML-snippet to find directives on
  where it should be placed in another template HTML file -- located
  in the templates/ directory of the application.
\item The combined HTML is then parsed for directives again for calls
  to the app.xql and places the result in the HTML element calling the
  xquery function.
\item In our case the app.xql will call a transformation function with
  the appropriate stylesheet and return the output into the HTML view.
\end{enumerate}
\paragraph{Notes}
There were ambiguous or vague matters in the assignment, which
collection to use was already addressed in the beginning of this
section, but there were x more issues: (1) What is meant by a
character's \emph{part} for a given scene/act was not defined. Nowhere
in the XML-files is a character's part described in any other way than
just his/her lines -- though it seemed odd to list those, we do so,
and the act/scene can be chosen from the table of contents.

Another (2) issue is that it is unclear where in the XML-files the
\emph{stage's requirements} are defined. (This holds for both the
types of Shakespeare collections referred to in the beginning of this
section.) For now we have listed all the stage directions, which do
include the items and such.
\end{document}
